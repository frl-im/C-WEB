<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced C/C++ Code Logic Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 300px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .code-panel, .visualization-panel, .memory-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .panel-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .panel-icon {
            width: 28px;
            height: 28px;
            margin-right: 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .code-icon {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .visual-icon {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .memory-icon {
            background: linear-gradient(45deg, #FF5722, #E64A19);
        }

        .code-editor-container {
            position: relative;
            height: 450px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #1e1e1e;
            overflow: hidden;
        }

        .code-editor-container:focus-within {
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
        }

        #codeInput {
            width: 100%;
            height: 100%;
            border: none;
            padding: 15px 50px 15px 50px;
            font-family: 'JetBrains Mono', 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            background: transparent;
            color: #d4d4d4;
            outline: none;
            position: relative;
            z-index: 2;
        }

        .line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 40px;
            background: #2d2d2d;
            border-right: 1px solid #404040;
            padding: 15px 5px;
            font-family: 'JetBrains Mono', 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            color: #858585;
            text-align: right;
            overflow: hidden;
            z-index: 1;
        }

        .line-tracking {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 40px;
            background: #2d2d2d;
            border-left: 1px solid #404040;
            z-index: 3;
            overflow: hidden;
        }

        .line-indicator {
            height: 22.4px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.3s;
            cursor: pointer;
        }

        .line-indicator.active {
            background: #4CAF50;
            color: white;
            animation: pulse 1s infinite;
        }

        .line-indicator.executed {
            background: #2196F3;
            color: white;
        }

        .line-indicator.current {
            background: #FF5722;
            color: white;
            animation: blink 1s infinite;
        }

        .line-indicator.error {
            background: #f44336;
            color: white;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .code-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Segoe UI', sans-serif;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #4CAF50;
        }

        .code-tooltip.show {
            opacity: 1;
        }

        .execution-marker {
            position: absolute;
            left: 45px;
            right: 45px;
            height: 22.4px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            border-radius: 3px;
            z-index: 1;
            opacity: 0;
            transition: all 0.3s;
        }

        .execution-marker.show {
            opacity: 1;
        }

        .visualization-container, .memory-container {
            height: 450px;
            overflow-y: auto;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }

        .step-item {
            background: #fff;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            animation: slideIn 0.4s ease-out;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        .step-item.executing {
            border-left-color: #4CAF50;
            background: linear-gradient(90deg, #e8f5e8 0%, #fff 100%);
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
        }

        .step-item.variable { border-left-color: #2196F3; }
        .step-item.control { border-left-color: #ff9800; }
        .step-item.function { border-left-color: #9c27b0; }
        .step-item.loop { border-left-color: #4caf50; }
        .step-item.error { border-left-color: #f44336; background: #ffebee; }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .memory-display {
            background: #f0f7ff;
            border: 1px solid #2196F3;
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        .memory-address {
            color: #666;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .variable-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .variable-name {
            font-weight: bold;
            color: #1976D2;
        }

        .variable-value {
            background: #4CAF50;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
        }

        .compilation-status {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #4CAF50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .compilation-status.error {
            border-left-color: #f44336;
            background: rgba(255,235,238,0.95);
        }

        .execution-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
        }

        .speed-slider {
            width: 100px;
        }

        .line-highlight {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #4CAF50;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
        }

        .examples {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .example-code {
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .example-code::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(76,175,80,0.1), transparent);
            transition: left 0.5s;
        }

        .example-code:hover::before {
            left: 100%;
        }

        .example-code:hover {
            border-color: #4CAF50;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .complexity-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 8px;
        }

        .complexity-beginner { background: #4CAF50; color: white; }
        .complexity-intermediate { background: #FF9800; color: white; }
        .complexity-advanced { background: #f44336; color: white; }

        .stats-panel {
            grid-column: span 3;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 10px;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #2196F3;
            display: block;
        }

        .stat-label {
            color: #666;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
            
            .memory-panel {
                grid-column: span 2;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }

        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .comment { color: #6a9955; }
        .function { color: #dcdcaa; }
        .variable { color: #9cdcfe; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° Advanced C/C++ Code Logic Visualizer</h1>
            <p>Experience realistic code execution with memory tracking, syntax highlighting, and step-by-step debugging!</p>
        </div>

        <div class="compilation-status" id="compilationStatus">
            <strong>üîß Ready to compile and execute</strong> - Enter your C/C++ code and click "Compile & Run"
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="compileAndRun()" id="runBtn">
                üöÄ Compile & Run
            </button>
            <button class="btn btn-secondary" onclick="stepThrough()" id="stepBtn" disabled>
                üë£ Step Through
            </button>
            <button class="btn btn-warning" onclick="resetExecution()" id="resetBtn" disabled>
                üîÑ Reset
            </button>
            <button class="btn btn-secondary" onclick="clearAll()">
                üóëÔ∏è Clear All
            </button>
        </div>

        <div class="execution-controls">
            <div class="speed-control">
                <span>Execution Speed:</span>
                <input type="range" class="speed-slider" id="speedSlider" min="1" max="10" value="5">
                <span id="speedLabel">Normal</span>
            </div>
        </div>

        <div class="main-content">
            <div class="code-panel">
                <div class="panel-header">
                    <div class="panel-icon code-icon">&lt;/&gt;</div>
                    C/C++ Code Editor with Live Tracking
                </div>
                <div class="code-editor-container">
                    <div class="line-numbers" id="lineNumbers">1</div>
                    <textarea id="codeInput" placeholder="Enter your C/C++ code here...

Example:
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int y = 20;
    int sum = x + y;
    
    if (sum > 25) {
        cout << &quot;Sum is greater than 25: &quot; << sum << endl;
    } else {
        cout << &quot;Sum is not greater than 25: &quot; << sum << endl;
    }
    
    for (int i = 0; i < 3; i++) {
        cout << &quot;Loop iteration &quot; << i << &quot;: i = &quot; << i << endl;
    }
    
    return 0;
}"></textarea>
                    <div class="line-tracking" id="lineTracking"></div>
                    <div class="execution-marker" id="executionMarker"></div>
                </div>
                <div class="code-tooltip" id="codeTooltip"></div>
            </div>

            <div class="visualization-panel">
                <div class="panel-header">
                    <div class="panel-icon visual-icon">üé¨</div>
                    Execution Visualization
                </div>
                <div class="visualization-container" id="visualizationArea">
                    <div style="text-align: center; color: #666; margin-top: 150px;">
                        <h3>üéØ Ready for execution!</h3>
                        <p>Write your C/C++ code and click "Compile & Run" to see detailed execution steps.</p>
                    </div>
                </div>
            </div>

            <div class="memory-panel">
                <div class="panel-header">
                    <div class="panel-icon memory-icon">üß†</div>
                    Memory & Variables
                </div>
                <div class="memory-container" id="memoryArea">
                    <div style="text-align: center; color: #666; margin-top: 150px;">
                        <h3>üíæ Memory Empty</h3>
                        <p>Variables will appear here during execution.</p>
                    </div>
                </div>
            </div>

            <div class="stats-panel">
                <div class="stat-item">
                    <span class="stat-number" id="linesCount">0</span>
                    <div class="stat-label">Lines of Code</div>
                </div>
                <div class="stat-item">
                    <span class="stat-number" id="variablesCount">0</span>
                    <div class="stat-label">Variables</div>
                </div>
                <div class="stat-item">
                    <span class="stat-number" id="operationsCount">0</span>
                    <div class="stat-label">Operations</div>
                </div>
                <div class="stat-item">
                    <span class="stat-number" id="executionTime">0ms</span>
                    <div class="stat-label">Execution Time</div>
                </div>
            </div>
        </div>

        <div class="examples">
            <div class="panel-header">
                <div class="panel-icon" style="background: linear-gradient(45deg, #FF5722, #E64A19);">üí°</div>
                Code Examples - Try These!
            </div>
            <div class="example-code" onclick="loadExample(1)">
                <strong>üî¢ Basic Variables & Arithmetic</strong>
                <span class="complexity-indicator complexity-beginner">BEGINNER</span><br>
                <span style="color: #6a9955;">// Variable declarations and basic math operations</span><br>
                <span class="keyword">int</span> a = <span class="number">15</span>; <span class="keyword">int</span> b = <span class="number">25</span>; <span class="keyword">int</span> result = a + b;
            </div>
            <div class="example-code" onclick="loadExample(2)">
                <strong>üîÄ Conditional Logic</strong>
                <span class="complexity-indicator complexity-beginner">BEGINNER</span><br>
                <span style="color: #6a9955;">// If-else statements with multiple conditions</span><br>
                <span class="keyword">if</span> (x > <span class="number">0</span>) { <span class="function">cout</span> << <span class="string">"Positive"</span>; }
            </div>
            <div class="example-code" onclick="loadExample(3)">
                <strong>üîÑ For Loop with Output</strong>
                <span class="complexity-indicator complexity-intermediate">INTERMEDIATE</span><br>
                <span style="color: #6a9955;">// Loop iteration with variable tracking</span><br>
                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++) { <span class="function">cout</span> << i; }
            </div>
            <div class="example-code" onclick="loadExample(4)">
                <strong>üåÄ While Loop with Counter</strong>
                <span class="complexity-indicator complexity-intermediate">INTERMEDIATE</span><br>
                <span style="color: #6a9955;">// While loop with increment operations</span><br>
                <span class="keyword">int</span> count = <span class="number">0</span>; <span class="keyword">while</span> (count < <span class="number">4</span>) { count++; }
            </div>
            <div class="example-code" onclick="loadExample(5)">
                <strong>üéØ Nested Loops & Complex Logic</strong>
                <span class="complexity-indicator complexity-advanced">ADVANCED</span><br>
                <span style="color: #6a9955;">// Advanced: Nested loops with multiple variables</span><br>
                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++) { <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">2</span>; j++) { ... } }
            </div>
        </div>
    </div>

    <script>
        let executionSteps = [];
        let currentStep = 0;
        let executionState = 'ready'; // ready, compiled, running, paused, finished
        let variables = {};
        let memoryAddresses = {};
        let addressCounter = 0x1000;
        let executionStartTime = 0;
        let lineToStepMapping = {}; // Maps line numbers to execution steps
        let currentExecutingLine = -1;

        // Initialize code editor features
        function initializeCodeEditor() {
            const codeInput = document.getElementById('codeInput');
            const lineNumbers = document.getElementById('lineNumbers');
            const lineTracking = document.getElementById('lineTracking');
            const tooltip = document.getElementById('codeTooltip');
            
            // Update line numbers and tracking on input
            codeInput.addEventListener('input', updateLineNumbers);
            codeInput.addEventListener('scroll', syncScroll);
            
            // Add hover tooltips for line tracking
            lineTracking.addEventListener('mouseover', showLineTooltip);
            lineTracking.addEventListener('mouseout', hideLineTooltip);
            
            // Initial update
            updateLineNumbers();
        }

        function updateLineNumbers() {
            const codeInput = document.getElementById('codeInput');
            const lineNumbers = document.getElementById('lineNumbers');
            const lineTracking = document.getElementById('lineTracking');
            
            const lines = codeInput.value.split('\n');
            const totalLines = lines.length;
            
            // Update line numbers
            let numberText = '';
            for (let i = 1; i <= totalLines; i++) {
                numberText += i + '\n';
            }
            lineNumbers.textContent = numberText;
            
            // Update line tracking indicators
            let trackingHTML = '';
            for (let i = 0; i < totalLines; i++) {
                const lineNum = i + 1;
                const stepInfo = lineToStepMapping[lineNum];
                let className = 'line-indicator';
                let content = '';
                
                if (stepInfo) {
                    if (lineNum === currentExecutingLine) {
                        className += ' current';
                        content = '‚ñ∂';
                    } else if (stepInfo.executed) {
                        className += ' executed';
                        content = '‚úì';
                    } else {
                        className += ' active';
                        content = stepInfo.stepNumber;
                    }
                }
                
                trackingHTML += `<div class="${className}" data-line="${lineNum}" data-step="${stepInfo ? stepInfo.stepNumber : ''}">${content}</div>`;
            }
            lineTracking.innerHTML = trackingHTML;
        }

        function syncScroll() {
            const codeInput = document.getElementById('codeInput');
            const lineNumbers = document.getElementById('lineNumbers');
            const lineTracking = document.getElementById('lineTracking');
            
            lineNumbers.scrollTop = codeInput.scrollTop;
            lineTracking.scrollTop = codeInput.scrollTop;
        }

        function showLineTooltip(event) {
            const target = event.target;
            if (!target.classList.contains('line-indicator')) return;
            
            const lineNum = parseInt(target.dataset.line);
            const stepNum = target.dataset.step;
            const tooltip = document.getElementById('codeTooltip');
            
            if (!stepNum) return;
            
            const stepInfo = lineToStepMapping[lineNum];
            if (!stepInfo) return;
            
            let tooltipContent = '';
            if (stepInfo.executed) {
                tooltipContent = `<strong>‚úÖ Executed</strong><br>Step ${stepNum}: ${stepInfo.description}<br><small>Result: ${stepInfo.result || 'Completed'}</small>`;
            } else if (lineNum === currentExecutingLine) {
                tooltipContent = `<strong>‚ñ∂Ô∏è Currently Executing</strong><br>Step ${stepNum}: ${stepInfo.description}`;
            } else {
                tooltipContent = `<strong>‚è≥ Pending</strong><br>Step ${stepNum}: ${stepInfo.description}`;
            }
            
            tooltip.innerHTML = tooltipContent;
            tooltip.className = 'code-tooltip show';
            
            // Position tooltip
            const rect = target.getBoundingClientRect();
            const containerRect = document.querySelector('.code-panel').getBoundingClientRect();
            tooltip.style.left = (rect.left - containerRect.left - 320) + 'px';
            tooltip.style.top = (rect.top - containerRect.top) + 'px';
        }

        function hideLineTooltip() {
            const tooltip = document.getElementById('codeTooltip');
            tooltip.classList.remove('show');
        }

        function highlightExecutingLine(lineNum) {
            currentExecutingLine = lineNum;
            const executionMarker = document.getElementById('executionMarker');
            const codeInput = document.getElementById('codeInput');
            
            if (lineNum > 0) {
                const lineHeight = 22.4; // Based on line-height * font-size
                const topPosition = (lineNum - 1) * lineHeight + 15; // 15px for padding
                
                executionMarker.style.top = topPosition + 'px';
                executionMarker.classList.add('show');
                
                // Auto-scroll to current line
                const containerHeight = codeInput.clientHeight;
                const scrollTop = Math.max(0, topPosition - containerHeight / 2);
                codeInput.scrollTop = scrollTop;
            } else {
                executionMarker.classList.remove('show');
            }
            
            updateLineNumbers();
        }

        function markLineAsExecuted(lineNum, result = null) {
            if (lineToStepMapping[lineNum]) {
                lineToStepMapping[lineNum].executed = true;
                lineToStepMapping[lineNum].result = result;
            }
            updateLineNumbers();
        }

        // Speed control
        const speedSlider = document.getElementById('speedSlider');
        const speedLabel = document.getElementById('speedLabel');
        
        speedSlider.addEventListener('input', function() {
            const speeds = ['Very Slow', 'Slow', 'Slow', 'Normal', 'Normal', 'Normal', 'Fast', 'Fast', 'Very Fast', 'Instant'];
            speedLabel.textContent = speeds[this.value - 1];
        });

        function getExecutionDelay() {
            const speed = parseInt(speedSlider.value);
            const delays = [2000, 1500, 1200, 1000, 800, 600, 400, 200, 100, 50];
            return delays[speed - 1];
        }

        function compileAndRun() {
            const code = document.getElementById('codeInput').value;
            const statusDiv = document.getElementById('compilationStatus');
            
            if (!code.trim()) {
                updateCompilationStatus('‚ùå Compilation Error: No source code provided', true);
                return;
            }
            
            // Simulate compilation
            updateCompilationStatus('üîß Compiling...', false);
            
            setTimeout(() => {
                if (analyzeAndCompileCode(code)) {
                    updateCompilationStatus('‚úÖ Compilation Successful - Ready to execute', false);
                    executionState = 'compiled';
                    updateButtons();
                    executeCode();
                } else {
                    updateCompilationStatus('‚ùå Compilation Error: Syntax issues detected', true);
                }
            }, 1000);
        }

        function analyzeAndCompileCode(code) {
            // Reset execution state
            executionSteps = [];
            currentStep = 0;
            variables = {};
            memoryAddresses = {};
            addressCounter = 0x1000;
            lineToStepMapping = {};
            currentExecutingLine = -1;
            
            // Basic syntax validation
            const requiredElements = ['#include', 'main()', '{', '}'];
            for (const element of requiredElements) {
                if (!code.includes(element)) {
                    return false;
                }
            }
            
            // Analyze code structure
            const lines = code.split('\n');
            let stepCounter = 1;
            let inMainFunction = false;
            let braceCount = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                const lineNum = i + 1;
                
                if (!trimmedLine || trimmedLine.startsWith('#') || trimmedLine.startsWith('using')) {
                    continue;
                }
                
                // Track braces for scope
                braceCount += (line.match(/{/g) || []).length;
                braceCount -= (line.match(/}/g) || []).length;
                
                if (trimmedLine.includes('int main()') || trimmedLine.includes('main()')) {
                    inMainFunction = true;
                    const stepInfo = {
                        type: 'function',
                        step: stepCounter++,
                        content: `üöÄ <strong>Program Entry Point</strong>`,
                        line: lineNum,
                        details: 'Execution begins at main() function',
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        description: 'Program starts execution'
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: 'Program Entry Point',
                        executed: false
                    };
                    continue;
                }
                
                if (!inMainFunction || trimmedLine === '{' || trimmedLine === '}') {
                    continue;
                }
                
                // Enhanced variable detection with types
                const varDeclarationMatch = trimmedLine.match(/(int|float|double|char|string|bool)\s+(\w+)\s*=\s*(.+?);/);
                if (varDeclarationMatch) {
                    const varType = varDeclarationMatch[1];
                    const varName = varDeclarationMatch[2];
                    const varValue = evaluateExpression(varDeclarationMatch[3], variables);
                    
                    variables[varName] = { value: varValue, type: varType };
                    memoryAddresses[varName] = generateMemoryAddress();
                    
                    const stepInfo = {
                        type: 'variable',
                        step: stepCounter++,
                        content: `üì¶ <strong>Variable Declaration:</strong> ${varType} ${varName} = ${varValue}`,
                        line: lineNum,
                        details: `Allocated memory at ${memoryAddresses[varName]} for ${varType} variable '${varName}'`,
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        description: `Declare ${varType} ${varName}`,
                        result: `${varName} = ${varValue}`
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: `Declare ${varType} ${varName}`,
                        executed: false,
                        result: `${varName} = ${varValue}`
                    };
                    continue;
                }
                
                // Variable assignment
                const assignMatch = trimmedLine.match(/(\w+)\s*=\s*(.+?);/);
                if (assignMatch && variables.hasOwnProperty(assignMatch[1])) {
                    const varName = assignMatch[1];
                    const oldValue = variables[varName].value;
                    const newValue = evaluateExpression(assignMatch[2], variables);
                    variables[varName].value = newValue;
                    
                    const stepInfo = {
                        type: 'variable',
                        step: stepCounter++,
                        content: `üîÑ <strong>Variable Update:</strong> ${varName} = ${newValue}`,
                        line: lineNum,
                        details: `Changed ${varName} from ${oldValue} to ${newValue} at memory ${memoryAddresses[varName]}`,
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        description: `Update ${varName}`,
                        result: `${oldValue} ‚Üí ${newValue}`
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: `Update ${varName}`,
                        executed: false,
                        result: `${oldValue} ‚Üí ${newValue}`
                    };
                    continue;
                }
                
                // Enhanced cout detection
                if (trimmedLine.includes('cout') && trimmedLine.includes('<<')) {
                    const outputText = extractCoutText(trimmedLine, variables);
                    
                    const stepInfo = {
                        type: 'function',
                        step: stepCounter++,
                        content: `üì∫ <strong>Console Output:</strong> "${outputText}"`,
                        line: lineNum,
                        details: 'Writing to standard output stream (stdout)',
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        output: outputText,
                        description: 'Print to console',
                        result: `Output: "${outputText}"`
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: 'Print to console',
                        executed: false,
                        result: `Output: "${outputText}"`
                    };
                    continue;
                }
                
                // Enhanced if statement handling
                const ifMatch = trimmedLine.match(/if\s*\((.+?)\)/);
                if (ifMatch) {
                    const condition = ifMatch[1];
                    const conditionResult = evaluateCondition(condition, variables);
                    
                    const stepInfo = {
                        type: 'control',
                        step: stepCounter++,
                        content: `ü§î <strong>Conditional Branch:</strong> if (${condition}) ‚Üí ${conditionResult ? 'TRUE' : 'FALSE'}`,
                        line: lineNum,
                        details: `${conditionResult ? 'Condition evaluated to true, entering if block' : 'Condition evaluated to false, skipping if block'}`,
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        conditionResult: conditionResult,
                        description: `Check condition: ${condition}`,
                        result: conditionResult ? 'TRUE' : 'FALSE'
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: `Check: ${condition}`,
                        executed: false,
                        result: conditionResult ? 'TRUE' : 'FALSE'
                    };
                    continue;
                }
                
                // Enhanced for loop handling
                const forMatch = trimmedLine.match(/for\s*\(\s*(int\s+)?(\w+)\s*=\s*(\d+)\s*;\s*\w+\s*<\s*(\d+)\s*;\s*\w+(\+\+|--)\s*\)/);
                if (forMatch) {
                    const loopVar = forMatch[2];
                    const startVal = parseInt(forMatch[3]);
                    const endVal = parseInt(forMatch[4]);
                    const increment = forMatch[5] === '++';
                    const iterations = increment ? endVal - startVal : startVal - endVal;
                    
                    const stepInfo = {
                        type: 'loop',
                        step: stepCounter++,
                        content: `üîÑ <strong>For Loop Initialization:</strong> ${loopVar} from ${startVal} to ${endVal-1}`,
                        line: lineNum,
                        details: `Loop will execute ${iterations} times with ${loopVar} ${increment ? 'incrementing' : 'decrementing'}`,
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        loopInfo: { variable: loopVar, start: startVal, end: endVal, iterations: iterations },
                        description: `For loop: ${loopVar} = ${startVal} to ${endVal-1}`,
                        result: `${iterations} iterations`
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: `For loop: ${loopVar}`,
                        executed: false,
                        result: `${iterations} iterations`
                    };
                    
                    // Simulate loop iterations
                    if (increment) {
                        for (let j = startVal; j < endVal; j++) {
                            if (!variables[loopVar]) {
                                variables[loopVar] = { value: j, type: 'int' };
                                memoryAddresses[loopVar] = generateMemoryAddress();
                            } else {
                                variables[loopVar].value = j;
                            }
                            
                            const iterStepInfo = {
                                type: 'loop',
                                step: stepCounter++,
                                content: `üîÅ <strong>Loop Iteration ${j - startVal + 1}:</strong> ${loopVar} = ${j}`,
                                line: lineNum,
                                details: `Iteration ${j - startVal + 1} of ${iterations}, ${loopVar} updated to ${j}`,
                                variables: {...variables},
                                memoryState: {...memoryAddresses},
                                iterationInfo: { current: j, iteration: j - startVal + 1, total: iterations },
                                description: `Loop iteration ${j - startVal + 1}`,
                                result: `${loopVar} = ${j}`
                            };
                            executionSteps.push(iterStepInfo);
                        }
                    }
                    continue;
                }
                
                // While loop handling
                const whileMatch = trimmedLine.match(/while\s*\((.+?)\)/);
                if (whileMatch) {
                    const condition = whileMatch[1];
                    const stepInfo = {
                        type: 'loop',
                        step: stepCounter++,
                        content: `üåÄ <strong>While Loop Started:</strong> while (${condition})`,
                        line: lineNum,
                        details: `Entering while loop, condition will be checked each iteration`,
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        description: `While loop: ${condition}`,
                        result: 'Loop started'
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: `While: ${condition}`,
                        executed: false,
                        result: 'Loop started'
                    };
                    continue;
                }
                
                // Return statement
                if (trimmedLine.includes('return')) {
                    const returnMatch = trimmedLine.match(/return\s+(.+?);/);
                    const returnValue = returnMatch ? evaluateExpression(returnMatch[1], variables) : 0;
                    
                    const stepInfo = {
                        type: 'function',
                        step: stepCounter++,
                        content: `üèÅ <strong>Program Termination:</strong> return ${returnValue}`,
                        line: lineNum,
                        details: `Main function returns ${returnValue}, program execution completed`,
                        variables: {...variables},
                        memoryState: {...memoryAddresses},
                        returnValue: returnValue,
                        description: 'Program ends',
                        result: `Return ${returnValue}`
                    };
                    executionSteps.push(stepInfo);
                    lineToStepMapping[lineNum] = {
                        stepNumber: stepInfo.step,
                        description: 'Program ends',
                        executed: false,
                        result: `Return ${returnValue}`
                    };
                    break;
                }
            }
            
            // Update line tracking display
            updateLineNumbers();
            
            return executionSteps.length > 0;
        }

        function generateMemoryAddress() {
            const address = `0x${addressCounter.toString(16).toUpperCase().padStart(4, '0')}`;
            addressCounter += 4; // Simulate 4-byte alignment
            return address;
        }

        function executeCode() {
            if (executionSteps.length === 0) return;
            
            executionState = 'running';
            executionStartTime = Date.now();
            updateButtons();
            updateStats();
            
            const visualArea = document.getElementById('visualizationArea');
            const memoryArea = document.getElementById('memoryArea');
            
            // Clear previous execution
            visualArea.innerHTML = '<div style="text-align: center; padding: 20px;"><h3>üé¨ Executing...</h3></div>';
            memoryArea.innerHTML = '<div style="text-align: center; padding: 20px;"><h3>üß† Memory Initializing...</h3></div>';
            
            executeStepByStep();
        }

        function executeStepByStep() {
            if (currentStep >= executionSteps.length) {
                executionState = 'finished';
                updateButtons();
                updateExecutionTime();
                return;
            }
            
            const step = executionSteps[currentStep];
            displayExecutionStep(step);
            updateMemoryDisplay(step);
            updateStats();
            
            currentStep++;
            
            setTimeout(() => {
                executeStepByStep();
            }, getExecutionDelay());
        }

        function stepThrough() {
            if (currentStep >= executionSteps.length) {
                executionState = 'finished';
                updateButtons();
                return;
            }
            
            const step = executionSteps[currentStep];
            displayExecutionStep(step);
            updateMemoryDisplay(step);
            updateStats();
            
            currentStep++;
            
            if (currentStep >= executionSteps.length) {
                executionState = 'finished';
                updateButtons();
                updateExecutionTime();
            }
        }

        function displayExecutionStep(step) {
            const visualArea = document.getElementById('visualizationArea');
            
            // Highlight the current line being executed
            highlightExecutingLine(step.line);
            
            // Create step element
            const stepElement = document.createElement('div');
            stepElement.className = `step-item ${step.type}`;
            stepElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-weight: bold; margin-bottom: 4px;">
                            <span style="background: #2196F3; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-right: 8px;">
                                Step ${step.step}
                            </span>
                            ${step.content}
                        </div>
                        <div style="font-size: 12px; color: #666; margin-left: 55px;">
                            ${step.details}
                        </div>
                        ${step.output ? `<div style="background: #f0f0f0; padding: 8px; margin: 8px 0 0 55px; border-radius: 4px; font-family: monospace; font-size: 12px;">Output: ${step.output}</div>` : ''}
                    </div>
                    <div class="line-highlight">Line ${step.line}</div>
                </div>
            `;
            
            // Clear container if this is the first step
            if (currentStep === 0) {
                visualArea.innerHTML = '';
            }
            
            visualArea.appendChild(stepElement);
            
            // Animate the step
            setTimeout(() => {
                stepElement.classList.add('executing');
                setTimeout(() => {
                    stepElement.classList.remove('executing');
                    // Mark line as executed
                    markLineAsExecuted(step.line, step.result);
                }, 1000);
            }, 100);
            
            // Auto-scroll to show latest step
            visualArea.scrollTop = visualArea.scrollHeight;
        }

        function updateMemoryDisplay(step) {
            const memoryArea = document.getElementById('memoryArea');
            
            if (Object.keys(step.variables).length === 0) {
                memoryArea.innerHTML = '<div style="text-align: center; color: #666; padding: 40px;"><h3>üíæ No Variables</h3><p>Memory is empty</p></div>';
                return;
            }
            
            let memoryHTML = '<div style="margin-bottom: 15px;"><h3 style="color: #2196F3; margin-bottom: 10px;">üß† Memory Layout</h3></div>';
            
            for (const [varName, varData] of Object.entries(step.variables)) {
                const address = step.memoryState[varName];
                memoryHTML += `
                    <div class="memory-display">
                        <div class="memory-address">Memory Address: ${address}</div>
                        <div class="variable-info">
                            <span class="variable-name">${varData.type} ${varName}</span>
                            <span class="variable-value">${varData.value}</span>
                        </div>
                    </div>
                `;
            }
            
            memoryArea.innerHTML = memoryHTML;
        }

        function updateStats() {
            const codeLines = document.getElementById('codeInput').value.split('\n').filter(line => line.trim()).length;
            const variableCount = Object.keys(variables).length;
            const operationCount = currentStep;
            
            document.getElementById('linesCount').textContent = codeLines;
            document.getElementById('variablesCount').textContent = variableCount;
            document.getElementById('operationsCount').textContent = operationCount;
        }

        function updateExecutionTime() {
            if (executionStartTime > 0) {
                const executionTime = Date.now() - executionStartTime;
                document.getElementById('executionTime').textContent = `${executionTime}ms`;
            }
        }

        function updateButtons() {
            const runBtn = document.getElementById('runBtn');
            const stepBtn = document.getElementById('stepBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            switch (executionState) {
                case 'ready':
                    runBtn.disabled = false;
                    stepBtn.disabled = true;
                    resetBtn.disabled = true;
                    runBtn.textContent = 'üöÄ Compile & Run';
                    break;
                case 'compiled':
                    runBtn.disabled = false;
                    stepBtn.disabled = false;
                    resetBtn.disabled = false;
                    runBtn.textContent = '‚ñ∂Ô∏è Execute';
                    break;
                case 'running':
                    runBtn.disabled = true;
                    stepBtn.disabled = true;
                    resetBtn.disabled = false;
                    break;
                case 'finished':
                    runBtn.disabled = false;
                    stepBtn.disabled = true;
                    resetBtn.disabled = false;
                    runBtn.textContent = 'üîÑ Run Again';
                    break;
            }
        }

        function updateCompilationStatus(message, isError) {
            const statusDiv = document.getElementById('compilationStatus');
            statusDiv.innerHTML = `<strong>${message}</strong>`;
            statusDiv.className = isError ? 'compilation-status error' : 'compilation-status';
        }

        function resetExecution() {
            executionSteps = [];
            currentStep = 0;
            variables = {};
            memoryAddresses = {};
            executionState = 'ready';
            executionStartTime = 0;
            lineToStepMapping = {};
            currentExecutingLine = -1;
            
            updateButtons();
            updateCompilationStatus('üîß Ready to compile and execute', false);
            
            // Clear line highlighting
            highlightExecutingLine(-1);
            updateLineNumbers();
            
            document.getElementById('visualizationArea').innerHTML = `
                <div style="text-align: center; color: #666; margin-top: 150px;">
                    <h3>üéØ Ready for execution!</h3>
                    <p>Write your C/C++ code and click "Compile & Run" to see detailed execution steps.</p>
                </div>
            `;
            
            document.getElementById('memoryArea').innerHTML = `
                <div style="text-align: center; color: #666; margin-top: 150px;">
                    <h3>üíæ Memory Empty</h3>
                    <p>Variables will appear here during execution.</p>
                </div>
            `;
            
            updateStats();
        }

        function clearAll() {
            document.getElementById('codeInput').value = '';
            resetExecution();
            updateLineNumbers();
        }

        // Enhanced expression evaluation
        function evaluateExpression(expr, variables) {
            expr = expr.replace(/;/g, '').trim();
            
            if (expr.match(/^".*"$/) || expr.match(/^'.*'$/)) {
                return expr.replace(/['"]/g, '');
            }
            
            let evaluatedExpr = expr;
            for (const [varName, varData] of Object.entries(variables)) {
                const regex = new RegExp(`\\b${varName}\\b`, 'g');
                evaluatedExpr = evaluatedExpr.replace(regex, varData.value);
            }
            
            try {
                if (evaluatedExpr.match(/^[\d\s+\-*/().]+$/)) {
                    return eval(evaluatedExpr);
                }
                return evaluatedExpr;
            } catch (e) {
                return expr;
            }
        }

        function evaluateCondition(condition, variables) {
            let evalCondition = condition;
            
            for (const [varName, varData] of Object.entries(variables)) {
                const regex = new RegExp(`\\b${varName}\\b`, 'g');
                evalCondition = evalCondition.replace(regex, varData.value);
            }
            
            try {
                if (evalCondition.match(/^[\d\s<>!=+\-*/().]+$/)) {
                    return eval(evalCondition);
                }
                return false;
            } catch (e) {
                return false;
            }
        }

        function extractCoutText(line, variables) {
            let output = '';
            const parts = line.split('<<');
            
            for (let i = 1; i < parts.length; i++) {
                let part = parts[i].trim();
                
                if (part.includes('endl')) continue;
                
                const stringMatch = part.match(/^"([^"]*)"/) || part.match(/^'([^']*)'/);
                if (stringMatch) {
                    output += stringMatch[1];
                    continue;
                }
                
                const varMatch = part.match(/^(\w+)/);
                if (varMatch && variables.hasOwnProperty(varMatch[1])) {
                    output += variables[varMatch[1]].value;
                    continue;
                }
                
                const valueMatch = part.match(/^(\d+)/);
                if (valueMatch) {
                    output += valueMatch[1];
                }
            }
            
            return output || 'Output generated';
        }

        function loadExample(exampleNum) {
            const examples = {
                1: `#include <iostream>
using namespace std;

int main() {
    int a = 15;
    int b = 25;
    int result = a + b;
    cout << "First number: " << a << endl;
    cout << "Second number: " << b << endl;
    cout << "Sum: " << result << endl;
    return 0;
}`,
                2: `#include <iostream>
using namespace std;

int main() {
    int x = 25;
    int y = 10;
    
    if (x > y) {
        cout << x << " is greater than " << y << endl;
    } else {
        cout << x << " is not greater than " << y << endl;
    }
    
    if (x > 20) {
        cout << "x is greater than 20" << endl;
    }
    
    return 0;
}`,
                3: `#include <iostream>
using namespace std;

int main() {
    cout << "For loop demonstration:" << endl;
    
    for (int i = 0; i < 5; i++) {
        cout << "Iteration " << i << ": i = " << i << endl;
    }
    
    cout << "Loop completed!" << endl;
    return 0;
}`,
                4: `#include <iostream>
using namespace std;

int main() {
    int count = 0;
    cout << "While loop demonstration:" << endl;
    
    while (count < 4) {
        cout << "Count is: " << count << endl;
        count++;
    }
    
    cout << "Final count: " << count << endl;
    return 0;
}`,
                5: `#include <iostream>
using namespace std;

int main() {
    cout << "Nested loops demonstration:" << endl;
    
    for (int i = 0; i < 3; i++) {
        cout << "Outer loop i = " << i << endl;
        
        for (int j = 0; j < 2; j++) {
            cout << "  Inner loop j = " << j << endl;
            int product = i * j;
            cout << "  Product: " << i << " * " << j << " = " << product << endl;
        }
    }
    
    return 0;
}`
            };
            
            document.getElementById('codeInput').value = examples[exampleNum];
            resetExecution();
        }

        // Auto-load example on page load
        window.onload = function() {
            initializeCodeEditor();
            setTimeout(() => {
                loadExample(1);
                updateStats();
            }, 500);
        };

        // Update stats when code changes
        document.getElementById('codeInput').addEventListener('input', function() {
            updateStats();
            resetExecution();
        });
    </script>
</body>
</html>